// 1. 修复API端点URL错误
Update(src/options/options.js)
  ⎿ 修正权限信息API端点URL
  @@ -src/options/options.js
  // 将错误的URL
  - const infoResponse = await fetch('https://open.feishu.cn/open-apis/authen/v1/access token info', {
  // 修正为正确的URL
  + const infoResponse = await fetch('https://open.feishu.cn/open-apis/authen/v1/access_token_info', {

// 2. 修复config未定义错误
Update(src/options/options.js)
  ⎿ 确保在debugTokenPermissions函数内正确获取config
  @@ -src/options/options.js
  async function debugTokenPermissions() {
    try {
      console.log('开始调试Token权限...');
      updateConnectionStatus("testing", "调试Token权限中...");
      
      // 确保正确获取配置
      + const config = await chrome.storage.sync.get([
      +   'feishuAppId', 
      +   'feishuAppSecret', 
      +   'feishuPersonalBaseToken'
      + ]);
      
      let accessToken = config.feishuPersonalBaseToken;
      
      // ... [其余代码] ...
    } catch (error) {
      // ... [错误处理] ...
    }
  }

// 3. 添加完整的错误处理和重试机制
Update(src/options/options.js)
  ⎿ 添加完整的API请求函数
  @@ -src/options/options.js
  // 添加安全的API请求函数
  + async function safeApiRequest(url, options = {}, retries = 3) {
  +   try {
  +     const response = await fetch(url, options);
  +     
  +     if (!response.ok) {
  +       if (response.status >= 500 && retries > 0) {
  +         // 服务器错误，重试
  +         console.log(`服务器错误，${retries}次重试机会...`);
  +         await new Promise(resolve => setTimeout(resolve, 1000));
  +         return safeApiRequest(url, options, retries - 1);
  +       }
  +       
  +       const errorText = await response.text();
  +       throw new Error(`API请求失败: ${response.status} ${response.statusText}\n${errorText}`);
  +     }
  +     
  +     return response;
  +   } catch (error) {
  +     if (retries > 0) {
  +       console.log(`请求失败，${retries}次重试机会...`, error.message);
  +       await new Promise(resolve => setTimeout(resolve, 500));
  +       return safeApiRequest(url, options, retries - 1);
  +     }
  +     throw error;
  +   }
  + }

// 4. 使用安全的API请求函数
Update(src/options/options.js)
  ⎿ 替换所有fetch调用为safeApiRequest
  @@ -src/options/options.js
  // 获取Token
  - const tokenResponse = await fetch('https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal', {
  + const tokenResponse = await safeApiRequest('https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        app_id: config.feishuAppId,
        app_secret: config.feishuAppSecret
      })
    });

  // 获取权限信息
  - const infoResponse = await fetch('https://open.feishu.cn/open-apis/authen/v1/access_token_info', {
  + const infoResponse = await safeApiRequest('https://open.feishu.cn/open-apis/authen/v1/access_token_info', {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

// 5. 添加API端点验证
Update(src/options/options.js)
  ⎿ 添加API端点验证函数
  @@ -src/options/options.js
  + async function verifyApiEndpoints() {
  +   const endpoints = [
  +     'https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal',
  +     'https://open.feishu.cn/open-apis/authen/v1/access_token_info'
  +   ];
  +   
  +   for (const endpoint of endpoints) {
  +     try {
  +       const response = await safeApiRequest(endpoint, { method: 'HEAD' });
  +       console.log(`API端点验证: ${endpoint} -> ${response.status}`);
  +     } catch (error) {
  +       console.error(`API端点不可用: ${endpoint}`, error);
  +     }
  +   }
  + }

// 6. 在调试开始时验证API端点
Update(src/options/options.js)
  ⎿ 在debugTokenPermissions中添加端点验证
  @@ -src/options/options.js
  async function debugTokenPermissions() {
    try {
      console.log('开始调试Token权限...');
      updateConnectionStatus("testing", "调试Token权限中...");
      
      // 验证API端点
      + await verifyApiEndpoints();
      
      // 获取配置
      const config = await chrome.storage.sync.get([
        'feishuAppId', 
        'feishuAppSecret', 
        'feishuPersonalBaseToken'
      ]);
      
      // ... [其余代码] ...
    } catch (error) {
      // ... [错误处理] ...
    }
  }

// 7. 构建并测试
Bash(pnpm build)