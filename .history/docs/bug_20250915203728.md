// 1. 修复JSON解析错误
Update(src/options/options.js)
  ⎿ 修改debugTokenPermissions函数
  @@ -src/options/options.js
  async function debugTokenPermissions() {
    try {
      // ... [其他代码] ...
      
      // 获取权限信息
      console.log('获取Token权限信息...');
      const infoResponse = await fetch('https://open.feishu.cn/open-apis/authen/v1/access_token_info', {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });
      
      // 添加响应状态检查
      if (!infoResponse.ok) {
        const errorText = await infoResponse.text();
        throw new Error(`API请求失败: ${infoResponse.status} ${infoResponse.statusText}\n响应内容: ${errorText}`);
      }
      
      // 添加内容类型检查
      const contentType = infoResponse.headers.get('content-type');
      if (!contentType || !contentType.includes('application/json')) {
        const body = await infoResponse.text();
        throw new Error(`无效的响应类型: ${contentType}\n响应内容: ${body}`);
      }
      
      const tokenInfo = await infoResponse.json();
      console.log('Token权限信息:', tokenInfo);
      
      // ... [其他代码] ...
    } catch (error) {
      // ... [错误处理] ...
    }
  }

// 2. 修复Token获取逻辑
Update(src/options/options.js)
  ⎿ 修改Token获取部分
  @@ -src/options/options.js
  if (!accessToken) {
    console.log('未找到保存的Token，尝试获取新Token...');
    
    const tokenResponse = await fetch('https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        app_id: config.feishuAppId,
        app_secret: config.feishuAppSecret
      })
    });
    
    // 添加响应检查
    if (!tokenResponse.ok) {
      const errorText = await tokenResponse.text();
      throw new Error(`获取Token失败: ${tokenResponse.status} ${tokenResponse.statusText}\n${errorText}`);
    }
    
    const tokenData = await tokenResponse.json();
    if (tokenData.code !== 0) {
      throw new Error(`获取Token失败: ${tokenData.msg} (code: ${tokenData.code})`);
    }
    
    accessToken = tokenData.tenant_access_token;
    console.log('新Token获取成功:', accessToken);
  }

// 3. 添加完整的错误日志
Update(src/options/options.js)
  ⎿ 增强错误处理
  @@ -src/options/options.js
  async function debugTokenPermissions() {
    try {
      // ... [代码] ...
    } catch (error) {
      console.error('调试失败详情:', {
        message: error.message,
        stack: error.stack,
        config: config // 记录当前配置
      });
      updateConnectionStatus("disconnected", "权限错误");
      showToast(`调试失败: ${error.message}`, 'error');
      throw error;
    }
  }

// 4. 添加重试机制
Update(src/options/options.js)
  ⎿ 添加API请求重试
  @@ -src/options/options.js
  async function safeFetch(url, options, retries = 2) {
    try {
      const response = await fetch(url, options);
      
      // 检查响应状态
      if (!response.ok) {
        if (response.status === 429 && retries > 0) { // 限流时重试
          console.log(`请求被限流，${retries}次重试机会...`);
          await new Promise(resolve => setTimeout(resolve, 1000));
          return safeFetch(url, options, retries - 1);
        }
        
        const errorText = await response.text();
        throw new Error(`请求失败: ${response.status} ${response.statusText}\n${errorText}`);
      }
      
      return response;
    } catch (error) {
      if (retries > 0) {
        console.log(`请求失败，${retries}次重试机会...`, error.message);
        await new Promise(resolve => setTimeout(resolve, 500));
        return safeFetch(url, options, retries - 1);
      }
      throw error;
    }
  }

  // 在debugTokenPermissions中使用safeFetch
  const tokenResponse = await safeFetch('https://open.feishu.cn/open-apis/auth/v3/tenant_access_token/internal', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      app_id: config.feishuAppId,
      app_secret: config.feishuAppSecret
    })
  });

  // 同样修改权限信息请求
  const infoResponse = await safeFetch('https://open.feishu.cn/open-apis/authen/v1/access_token_info', {
    headers: {
      'Authorization': `Bearer ${accessToken}`
    }
  });

// 5. 构建并测试
Bash(pnpm build)